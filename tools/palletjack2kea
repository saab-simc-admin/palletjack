#!/usr/bin/env ruby

# Write configuration for the Kea DHCP server from a Palletjack warehouse

require 'palletjack'
require 'optparse'
require 'json'

options = {}

opts = OptionParser.new
opts.banner = "Usage: #{$PROGRAM_NAME} [options] <name> ...

Write configuration for the Kea DHCP server from a Palletjack warehouse

"
opts.on('-w DIR', '--warehouse DIR', 'warehouse directory', String) {|dir| options[:warehouse] = dir }
opts.on('-s SERVICE', '--service SERVICE', 'service name for global configuration', String) {|service| options[:service] = service }
opts.parse!

if not options[:warehouse] or
  not options[:service]
  puts opts.to_s
  exit 1
end

jack = PalletJack.new(options[:warehouse])

kea_config = { 'Dhcp4' => {} }

jack['service', name:options[:service]].each do |service_config|
  kea_config['Dhcp4'] = service_config['service.kea_v4']
end

kea_config['Dhcp4']['subnet4'] = []

jack['ipv4_network'].each do |net|
  net_config = {'subnet' => "#{net['net.ipv4.cidr']}",
                'reservations' => [],
                'option-data' => []}
  if net['net.ipv4.gateway']
    net_config['option-data'] << {
      'name' => 'routers',
      'code' => 3,
      'space' => 'dhcp4',
      'csv-format' => true,
      'data' => "#{net['net.ipv4.gateway']}"
    }
  end

  if net['net.dns.resolver']
    resolvers = ''
    net['net.dns.resolver'].each do |resolver|
      resolvers << resolver << ', '
    end

    net_config['option-data'] << {
      'name' => 'domain-name-servers',
      'code' => 6,
      'space' => 'dhcp4',
      'csv-format' => true,
      'data' => resolvers.chomp(', ')
    }
  end

  if net['net.dhcp.tftp-server']
    net_config['option-data'] << {
      'name' => 'tftp-server-name',
      'code' => 66,
      'space' => 'dhcp4',
      'csv-format' => true,
      'data' => net['net.dhcp.tftp-server']
    }

    # Option 66 is the standard way of sending a TFTP server address, but some
    # DHCP clients still want it in the next-server field.
    net_config['next-server'] = net['net.dhcp.tftp-server']
  end

  if net['net.dhcp.boot-file']
    net_config['option-data'] << {
      'name' => 'boot-file-name',
      'code' => 67,
      'space' => 'dhcp4',
      'csv-format' => true,
      'data' => net['net.dhcp.boot-file']
    }
  end

  jack['ipv4_interface',
       with_all:{'pallet.ipv4_network' =>
                 net['pallet.ipv4_network']}].each do |interface|
    # There are interfaces in the example warehouse without
    # corresponding hardware, in order to be able to point at them in
    # generated DNS configuration. Ignore those here, since they
    # cannot run DHCP if they don't have MAC addresses.
    next if not interface['net.layer2.address']

    net_config['reservations'] << {
      'hw-address' => "#{interface['net.layer2.address']}",
      'ip-address' => "#{interface['net.ipv4.address']}",
      'hostname' => "#{interface['net.dns.fqdn']}",
      'option-data' => [ {
        'name' => 'domain-name',
        'code' => 15,
        'space' => 'dhcp4',
        'csv-format' => true,
        # Interfaces are attached to networks, which are attached to
        # domains, so if we look for a domain name from the interface
        # we'll get different ones depending on the interface. But
        # domain name is a property of the system, so look up the
        # system this interface is attached to and get its domain
        # name.
        'data' => jack.fetch('system', name:interface['pallet.system'])['net.dns.domain']
      } ]
    }
  end

  kea_config['Dhcp4']['subnet4'] << net_config
end

jj kea_config
