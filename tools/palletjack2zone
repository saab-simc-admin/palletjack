#!/usr/bin/env ruby

# Write DNS server zone file from a Palletjack warehouse
#
# Data model assumptions:
# - Each domain corresponds uniquely to one IPv4 network

require 'palletjack'
require 'optparse'
require 'dns/zone'
require 'ip'

options = {}

opts = OptionParser.new
opts.banner = "Usage: #{$PROGRAM_NAME} -w <warehouse> -d <output directory>

Write DNS server zone files from a Palletjack warehouse

"
opts.on("-w DIR", "--warehouse DIR", "warehouse directory", String) {|dir| options[:warehouse] = dir }
opts.on("-d DIR", "--output DIR", "output directory", String) {|dir| options[:output] = dir }
opts.parse!

if not options[:warehouse] or
    not options[:output] or
    not File.directory?(options[:output])
  puts opts.to_s
  exit 1
end

# Use Unix timestamp as serial number, and get it once so all zones get the same one
serial = Time.now.utc.to_i

jack = PalletJack.new(options[:warehouse])

jack["domain"].each do |domain|
  absolute_domain_name = "#{domain['net.dns.domain']}."

  zone = DNS::Zone.new

  zone.origin = absolute_domain_name
  zone.ttl = domain['net.dns.ttl']

  zone.soa.serial = serial
  zone.soa.label = absolute_domain_name
  zone.soa.nameserver = "#{domain['net.dns.soa-ns']}."
  zone.soa.email = "#{domain['net.dns.soa-contact']}.".sub('@', '.')

  if domain['net.dns.mx']
    domain['net.dns.mx'].each do |server|
      mx = DNS::Zone::RR::MX.new
      mx.label = absolute_domain_name
      mx.priority = server['priority']
      mx.exchange = "#{server['server']}."
      zone.records << mx
    end
  end

  domain['net.dns.ns'].each do |address|
    ns = DNS::Zone::RR::NS.new
    ns.label = absolute_domain_name
    ns.nameserver = "#{address}."
    zone.records << ns
  end

  jack["ipv4_interface",
       with_all:{"net.dns.domain" =>
                 domain['net.dns.domain']}].each do |interface|
    a = DNS::Zone::RR::A.new
    a.label = interface['net.dns.name']
    a.address = interface['net.ipv4.address']
    zone.records << a
  end

  File.open("#{options[:output]}/#{domain['net.dns.domain']}.zone", File::CREAT | File::TRUNC | File::WRONLY, 0644) do |zonefile|
    zonefile <<
";;;;;;;;;;
; Automatically generated by palletjack2zone from #{options[:warehouse]}
;;;;;;;;;;

"
    zonefile << zone.dump_pretty
  end

  next unless domain['net.ipv4.cidr']

  # Assume all delegations happen on octet boundaries for now.
  # TODO: RFC 2317 classless in-addr.arpa delegation

  reverse_zone = DNS::Zone.new

  ip_net = IP.new(domain['net.ipv4.cidr'])
  absolute_reverse_zone_name = ip_net.to_arpa

  prefix_octets, _ = domain['net.ipv4.prefixlen'].to_i.divmod(8)
  reverse_zone.origin = absolute_reverse_zone_name.split(".")[-(2 + prefix_octets) .. 5].join(".")

  reverse_zone.ttl = domain['net.dns.ttl']

  reverse_zone.soa.serial = serial
  reverse_zone.soa.label = "#{reverse_zone.origin}."
  reverse_zone.soa.nameserver = "#{domain['net.dns.soa-ns']}."
  reverse_zone.soa.email = "#{domain['net.dns.soa-contact']}.".sub('@', '.')

  domain['net.dns.ns'].each do |address|
    ns = DNS::Zone::RR::NS.new
    ns.label = reverse_zone.origin
    ns.nameserver = "#{address}."
    reverse_zone.records << ns
  end

  jack["ipv4_interface",
       with_all:{"net.dns.domain" =>
                 domain['net.dns.domain']}].each do |interface|
    ptr = DNS::Zone::RR::PTR.new
    ptr.label = IP.new(interface['net.ipv4.address']).to_arpa
    ptr.name = "#{interface['net.dns.fqdn']}."
    reverse_zone.records << ptr
  end

  File.open("#{options[:output]}/#{reverse_zone.origin}.zone", File::CREAT | File::TRUNC | File::WRONLY, 0644) do |zonefile|
    zonefile <<
";;;;;;;;;;
; Automatically generated by palletjack2zone from #{options[:warehouse]}
;;;;;;;;;;

"
    zonefile << reverse_zone.dump_pretty
  end
end
