#!/usr/bin/env ruby

# Write DNS server zone file from a Palletjack warehouse
#
# Data model assumptions:
# - Each domain corresponds uniquely to one IPv4 network

require 'palletjack'
require 'optparse'
require 'dns/zone'
require 'ip'

options = {}

opts = OptionParser.new
opts.banner = "Usage: #{$PROGRAM_NAME} -w <warehouse> -d <output directory>

Write DNS server zone files from a Palletjack warehouse

"
opts.on("-w DIR", "--warehouse DIR", "warehouse directory", String) {|dir| options[:warehouse] = dir }
opts.on("-d DIR", "--output DIR", "output directory", String) {|dir| options[:output] = dir }
opts.parse!

if not options[:warehouse] or
    not options[:output] or
    not File.directory?(options[:output])
  puts opts.to_s
  exit 1
end

jack = PalletJack.new(options[:warehouse])

jack["domain"].each do |domain|
  absolute_domain_name = "#{domain['net.domain.name']}."

  zone = DNS::Zone.new

  zone.origin = absolute_domain_name
  zone.ttl = domain['net.dns.ttl']

  zone.soa.label = absolute_domain_name
  zone.soa.nameserver = domain['net.dns.ns'][0]
  zone.soa.email = domain['net.dns.soa-contact']

  domain['net.dns.mx'].each do |server|
    mx = DNS::Zone::RR::MX.new
    mx.label = absolute_domain_name
    mx.priority = server['priority']
    mx.exchange = server['server']
    zone.records << mx
  end

  domain['net.dns.ns'].each do |address|
    ns = DNS::Zone::RR::NS.new
    ns.label = absolute_domain_name
    ns.nameserver = address
    zone.records << ns
  end

  jack["ip_interface",
       with_all:{"net.domain.name" =>
                 domain['net.domain.name']}].each do |interface|
    a = DNS::Zone::RR::A.new
    a.label = interface['net.ip.name']
    a.address = interface['net.ip.address']
    zone.records << a
  end

  File.open("#{options[:output]}/#{domain['net.domain.name']}.zone", File::CREAT | File::TRUNC | File::WRONLY, 0644) do |zonefile|
    zonefile <<
"##############################################################################
# Automatically generated by palletjack2zone from #{options[:warehouse]}
##############################################################################

"
    zonefile << zone.dump_pretty
  end

  next unless domain['net.ip.cidr']

  # Assume all delegations happen on octet boundaries for now.
  # TODO: RFC 2317 classless in-addr.arpa delegation

  reverse_zone = DNS::Zone.new

  ip_net = IP.new(domain['net.ip.cidr'])
  absolute_reverse_zone_name = ip_net.to_arpa

  prefix_octets, _ = domain['net.ip.prefixlen'].to_i.divmod(8)
  reverse_zone.origin = absolute_reverse_zone_name.split(".")[-(2 + prefix_octets) .. 5].join(".")

  reverse_zone.ttl = domain['net.dns.ttl']

  reverse_zone.soa.label = reverse_zone.origin
  reverse_zone.soa.nameserver = domain['net.dns.ns']
  reverse_zone.soa.email = domain['net.dns.soa-contact']

  jack["ip_interface",
       with_all:{"net.domain.name" =>
                 domain['net.domain.name']}].each do |interface|
    ptr = DNS::Zone::RR::PTR.new
    ptr.label = IP.new(interface['net.ip.address']).to_arpa
    ptr.name = interface['net.ip.name']
    reverse_zone.records << ptr
  end

  File.open("#{options[:output]}/#{reverse_zone.origin}.zone", File::CREAT | File::TRUNC | File::WRONLY, 0644) do |zonefile|
    zonefile <<
"##############################################################################
# Automatically generated by palletjack2zone from #{options[:warehouse]}
##############################################################################

"
    zonefile << reverse_zone.dump_pretty
  end
end
